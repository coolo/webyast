#--
# Copyright (c) 2009-2010 Novell, Inc.
#
# All Rights Reserved.
#
# This program is free software; you can redistribute it and/or modify it
# under the terms of version 2 of the GNU General Public License
# as published by the Free Software Foundation.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, contact Novell, Inc.
#
# To contact Novell about this file by physical or electronic mail,
# you may find current contact information at www.novell.com
#++

class NetworkController < ApplicationController
  NETMASK_RANGE = 0..32
  STATIC_BOOT_ID = "static"

<<<<<<< HEAD
def getCurrentIP
  ip, orig, Socket.do_not_reverse_lookup = "", Socket.do_not_reverse_lookup, true  # turn off reverse DNS resolution temporarily

  UDPSocket.open do |s|
    s.connect '64.233.187.99', 1
    ip = s.addr.last
=======
  def index
    authorize! :read, Network

    @ifcs = Interface.find(:all)
    @physical = @ifcs.select{|k, i| i if k.match("eth")}
    @virtual = @ifcs.select{|k, i| i unless k.match("eth")}

    respond_to do |format|
      format.html # show.html.erb
      format.json { render :json => @ifcs }
    end
>>>>>>> rails3_port
  end

  def edit
    authorize! :read, Network

    network = Network.find
    
    @hostname = network["hostname"]
    @dns = network["dns"]
    @routes = network["routes"]

    @ifcs = network["interfaces"]
    @ifc = @ifcs[params[:id]]

<<<<<<< HEAD
  # Initialize GetText and Content-Type.
  init_gettext "webyast-network"

  public
  def initialize
  end

  NETMASK_RANGE = 0..32
  STATIC_BOOT_ID = "static"


  # GET /network
  def index
    yapi_perm_check "network.read"
    @ifcs = Interface.find :all

    # FIXED: MODULE CRASHED IF BOTH INTERFACES HAS ATTRIBUTE BOOTPROTO !!!

    unless @ifcs.nil? || @ifcs.empty? #No network interfaces found

      unless @ifcs.length == 1
        logger.debug "***** More than one interface is attached -> #{ @ifcs.length } *****"
        Rails.logger.error @ifcs.to_hash.inspect

        @ifcs.each do |id, interface|
          unless interface.bootproto.nil?
            logger.error "** Interface #{interface.id} is active\n"
            ifc = Interface.find(id)
            @iface = id
          end
        end
      end

    else
      logger.error "***ERROR: No network interface found!"
=======
    @type = params[:id][0..(params[:id].size-2)] || "eth"
    @number = @ifcs.select{|id, iface| id if id.match(@type)}.count
    @physical = @ifcs.select{|k, i| i if k.match("eth")}


    respond_to do |format|
      format.html
      format.json { render :json => @ifc }
>>>>>>> rails3_port
    end
  end

<<<<<<< HEAD
    ifc = Interface.find @iface
    return false unless ifc

    # TODO use rescue_from "AR::Base not found..."
    # http://api.rubyonrails.org/classes/ActiveSupport/Rescuable/ClassMethods.html

    hn = Hostname.find
    return false unless hn

    dns = Dns.find
    return false unless dns

    rt = Route.find "default"
    return false unless rt

    @write_permission = yapi_perm_granted?("network.write")
=======
  def new
    authorize! :write, Network

    network = Network.find
    @hostname = network["hostname"]
    @ifcs = network["interfaces"]
    @dns = network["dns"]
    @routes = network["routes"]

    @type = params[:type]
    @number = @ifcs.select{|id, iface| id if id.match(@type)}.count
    @physical = @ifcs.select{|k, i| i if k.match("eth")}
>>>>>>> rails3_port

    @ifc = Interface.new({"type"=>params[:type], "bootproto"=>"dhcp", "startmode"=>"auto"}, "#{@type}#{@number}")

    #@dhcp_hostname_enabled = @hostname.respond_to?("dhcp_hostname")

    respond_to do |format|
      format.html # show.html.erb
      format.json { render :json => @ifc }
    end

<<<<<<< HEAD
    @ip, @netmask = ipaddr.split "/"
    # when detect PREFIXLEN with leading "/"
    if ifc.bootproto == STATIC_BOOT_ID && NETMASK_RANGE.include?(@netmask.to_i)
      @netmask = "/"+@netmask
      Rails.logger.error "\n*** set netmask if static and netmask in range #{@netmask} \n"
    end

    @name = hn.name
    @domain = hn.domain

    @dhcp_ip = getCurrentIP;

    @dhcp_hostname_enabled = hn.respond_to?("dhcp_hostname")
    @dhcp_hostname = @dhcp_hostname_enabled && hn.dhcp_hostname == "1"

    @nameservers = dns.nameservers
    @searchdomains = dns.searches
    @default_route = rt.via

    @conf_modes = {_("Manual")=>STATIC_BOOT_ID, _("Automatic")=>"dhcp"}
    @conf_modes[@conf_mode] =@conf_mode unless @conf_modes.has_value? @conf_mode
=======
>>>>>>> rails3_port
  end

  def create
    authorize! :write, Network

    hash = {}
    hash["type"] = params[:type] if  params[:type]
    hash["bootproto"] = params[:bootproto]
    hash["ipaddr"] = params[:ipaddr] || ""
    hash["vlan_id"] = params[:vlan_id] if  params[:vlan_id]
    hash["vlan_etherdevice"] = params[:vlan_etherdevice] if  params[:vlan_etherdevice]
    hash["bridge_ports"] = params["bridge_ports"].map{|k,v| k if v=="1"}.compact.join(' ').to_s || "" if params["bridge_ports"]
    hash["bond_slaves"] = params["bond_slaves"].map{|k,v| k if v=="1"}.compact.join(' ').to_s if params["bond_slaves"]

    if params["bond_mode"] && params["bond_miimon"]
      bond_option = "#{params["bond_mode"]} #{params["bond_miimon"].gsub(/ /,'')}"
      hash["bond_option"] = bond_option
    end
    
    ifc = Interface.new(hash, "#{params["type"]}#{params["number"]}")
    ifc.save

    redirect_to :controller => "network", :action => "index"
  end

  # PUT /users/1
  # PUT /users/1.xml
  def update
<<<<<<< HEAD
    yapi_perm_check "network.write"

    dirty = false
    dirty_ifc = false

    ### HOSTANE ###

    hn = Hostname.find

    return false unless hn
    dirty = true unless (hn.name == params["hostname"] && hn.domain == params["domain"])

    logger.info "\n*** INFO: dirty after hostname: #{dirty}\n"

    hn.name   = params["hostname"]
    hn.domain = params["domain"]
    Rails.logger.error "### DEBUG: set hostname #{hn.name} \n"
    Rails.logger.error "### DEBUG: set domain #{hn.domain} \n"
=======
    authorize! :write, Network

    dirty_hostname = false
    dirty_dns = false
    dirty_route = false
    dirty_ifc = false

    network = Network.find

    ### HOSTANEM ###
    hostname = network["hostname"]

    if hostname.name != params["hostname"] && hostname.domain != params["domain"]
      hostname.name   = params["hostname"]
      hostname.domain = params["domain"]

      dirty_hostname = true
    end
>>>>>>> rails3_port

    if params["dhcp_hostname_enabled"] == "true"
      hostname.dhcp_hostname = params["dhcp_hostname"] || "0"
      #params["dhcp_hostname"]==nil ? params["dhcp_hostname"]="0" : pass
<<<<<<< HEAD
      #Set dirty to true (bnc#692594)
      dirty = true
      hn.dhcp_hostname = params["dhcp_hostname"] || "0"
      Rails.logger.error "### DEBUG: set dhcp_hostname #{hn.dhcp_hostname} \n"

      logger.info "\n*** INFO: dirty after dhcp_hostname: #{dirty}\n"
=======
      dirty_hostname = true #Set dirty to true (bnc#692594)
>>>>>>> rails3_port
    end
    ### END HOSTNAME ###


<<<<<<< HEAD
    ### END HOSTANE ###


=======
>>>>>>> rails3_port
    ### DNS ###
    dns = network["dns"]

<<<<<<< HEAD
    dns = Dns.find
    return false unless dns

    # Simply comparing empty array and nil would wrongly mark it dirty,
    # so at first test emptiness
    #FIXME repair it when spliting of param is ready


=======
>>>>>>> rails3_port
    unless (dns.nameservers.empty? && params["nameservers"].blank?)
      dirty_dns = true unless dns.nameservers == (params["nameservers"]||"").split
    end

    unless (dns.searches.empty? && params["searchdomains"].blank?)
      dirty_dns = true unless dns.searches == (params["searchdomains"]||"").split
    end

<<<<<<< HEAD
    logger.info "\n*** INFO: dirty after  dns: #{dirty}\n"

    # now the model contains arrays but for saving
    # they need to be concatenated because we can't serialize them
    # FIXME: params bellow should be arrays


    Rails.logger.error "### ERROR: set dns_nameservers #{params["nameservers"]} \n"
    Rails.logger.error "### ERROR: set dns_searches #{params["searchdomains"]} \n"

=======
>>>>>>> rails3_port
    dns.nameservers = params["nameservers"].nil? ? [] : params["nameservers"].split
    dns.searches    = params["searchdomains"].nil? ? [] : params["searchdomains"].split
    ### END DNS ###


<<<<<<< HEAD
    Rails.logger.error "### DEBUG: set dns_nameservers #{dns.nameservers.inspect} \n"
    Rails.logger.error "### DEBUG: set dns_searches #{dns.searches.inspect} \n"

    ### END DNS ###


=======
>>>>>>> rails3_port
    ### INTERFACE ###
    ifc = Interface.find params["interface"]
<<<<<<< HEAD
    return false unless ifc

    dirty_ifc = true unless (ifc.bootproto == params["conf_mode"])
    logger.info "\n*** INFO: dirty after interface config: #{dirty}\n"

    ifc.bootproto=params["conf_mode"]

=======
    ifc.type = params["type"]

    dirty_ifc = true unless (ifc.bootproto == params["bootproto"])

    ifc.bootproto = params["bootproto"]
    
>>>>>>> rails3_port
    if ifc.bootproto == STATIC_BOOT_ID
        ifc.ipaddr = "#{params["ip"]}/#{ifc.netmask_to_cidr(params["netmask"])}"
        dirty_ifc = true
    end
<<<<<<< HEAD


   ### END INTERFACE ###


   ### ROUTE ###

   rt = Route.find "default"
   return false unless rt

   dirty = true unless rt.via == (params["default_route"] || "")
=======
>>>>>>> rails3_port

    if params[:vlan_id] && ifc.vlan_id != params[:vlan_id]
      ifc.vlan_id = params[:vlan_id]
      dirty_ifc = true
    end

    if params[:vlan_etherdevice] && ifc.vlan_etherdevice !=  params[:vlan_etherdevice]
      ifc.vlan_etherdevice = params[:vlan_etherdevice]
      dirty_ifc = true
    end

<<<<<<< HEAD
   ### END ROUTE ###



    # this is not transaction!
    # if any *.save failed, the previous will be applied
    # FIXME JR: I think that if user choose dhcp not all settings should be written


    Rails.logger.error "\n\nPARAMS #{params.inspect}\n\n"


    if dirty||dirty_ifc
      Rails.logger.error "\n==== BEFORE SAVE ===="
      Rails.logger.error "### HOSTNAME #{hn.inspect}"
      Rails.logger.error "### DNS #{dns.inspect}"
      Rails.logger.error "### ROUTE #{rt.inspect}"
      Rails.logger.error "==== END ===="

      rt.save
      dns.save
      hn.save

      # write interfaces (and therefore restart network) only when interface settings changed (bnc#579044)
      if dirty_ifc
        Rails.logger.error "\n==== BEFORE SAVE ===="
        Rails.logger.error "### INTERFACE #{ifc.inspect}\n"
        ifc.save
      end
=======
    if params["bridge_ports"] && ifc.bridge_ports != params["bridge_ports"]
      ifc.bridge_ports = params["bridge_ports"].map{|k,v| k if v=="1"}.compact.join(' ').to_s || ""
      dirty_ifc = true
    end
    
    if params["bond_slaves"] && ifc.bond_slaves != params["bond_slaves"]
      ifc.bond_slaves = params["bond_slaves"].map{|k,v| k if v=="1"}.compact.join(' ').to_s
      dirty_ifc = true
    end
    
    if params["bond_mode"] && params["bond_miimon"]
      bond_option = "#{params["bond_mode"]} #{params["bond_miimon"].gsub(/ /,'')}"
      if ifc.bond_option != bond_option
        ifc.bond_option = bond_option
        dirty_ifc = true
       end
    end
    
    if params["bond_mode"] && ifc.bond_option != params["bond_mode"]
       ifc.bond_option
    end
   ### END INTERFACE ###


   ### ROUTE ###
   route = network["routes"]

   if params["default_route"] && route.via != params["default_route"]
     route.via = params["default_route"]
     dirty_route = true
   end
   ### END ROUTE ###


    if dirty_route
      Rails.logger.error "*** ROUTE is dirty #{route.inspect}\n"
      route.save
    end

    if dirty_dns
      Rails.logger.error "*** DNS is dirty #{dns.inspect}\n"
      dns.save
>>>>>>> rails3_port
    end

    if dirty_hostname
      Rails.logger.error "*** HOSTNAME is dirty #{hostname.inspect}\n"
      hostname.save
    end

    # write interfaces (and therefore restart network) only when interface settings changed (bnc#579044)
    if dirty_ifc
      route.save
      dns.save
      hostname.save
      ifc.save
    end

     flash[:notice] = _('Network settings have been written.')
     redirect_to :controller => "network", :action => "index"
  end

  def destroy
    authorize! :write, Network

    ifc = Interface.find params[:id]
    ret = ifc.destroy
    redirect_to :controller => "network", :action => "index"
  end
end

